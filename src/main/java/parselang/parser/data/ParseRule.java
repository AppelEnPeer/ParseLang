package parselang.parser.data;

import java.util.*;

public class ParseRule {

    private final NonTerminal lhs;
    private List<Node> rhs = new LinkedList<>();
    private ParseRule origin = this;

    public ParseRule(NonTerminal lhs) {
        this.lhs = lhs;
    }

    public ParseRule(String lhs) {
        this.lhs = new NonTerminal(lhs);
    }

    public NonTerminal getLHS() {
        return lhs;
    }

    public void setRhs(List<Node> rhs) {
        this.rhs = rhs;
    }

    public ParseRule addRhs(Node node) {
        rhs.add(node);
        return this;
    }

    public ParseRule addRhs(Node... nodes) {
        rhs.addAll(Arrays.asList(nodes));
        return this;
    }

    public List<Node> getRHS() {
        return rhs;
    }



    public String toString() {
        StringBuilder sb = new StringBuilder(lhs.toString());
        sb.append(" = ");
        for (Node node : rhs) {
            sb.append(node).append(" ");
        }
        return sb.toString();
    }

    public ParseRule getOrigin() {
        ParseRule oldPR = null;
        ParseRule newPR = origin;
        while (!newPR.equals(oldPR)) {
            oldPR = newPR;
            newPR = oldPR.origin;
        }
        return newPR;
    }

    public List<ParseRule> convertStarNodes() {
        List<ParseRule> res = new ArrayList<>();
        ParseRule copy = this.copy();
        copy.origin = this;
        for (Node rhsNode : getRHS()) {
            if (rhsNode instanceof StarNode) {
                NonTerminal replacement = new NonTerminal("(" + rhsNode.toString() + ")");//NonTerminal.getNext();
                replacement.setSpecialStatus(NonTerminal.SpecialStatus.AUTOGENERATED_STAR);
                copy.replaceRHSNodes(rhsNode, replacement);
                ParseRule recursiveReplacement = new ParseRule(replacement);
                recursiveReplacement.origin = this;
                for (Node starContent : ((StarNode) rhsNode).contents()) {
                    recursiveReplacement.addRhs(starContent);
                }
                recursiveReplacement.addRhs(replacement);
                res.addAll(recursiveReplacement.convertStarNodes());
                ParseRule inheritanceRule = new ParseRule(replacement);
                inheritanceRule.origin = this;
                res.add(inheritanceRule);
            }
        }
        res.add(copy);
        return res;

    }

    private void replaceRHSNodes(Node rhsNode, NonTerminal replacement) {
        for (int i = 0; i < rhs.size(); i++) {
            if (rhs.get(i).equals(rhsNode)) {
                rhs.set(i, replacement);
            }
        }
    }

    private ParseRule copy() {
        ParseRule res = new ParseRule(this.lhs);
        res.addRhs(this.rhs.toArray(new Node[0]));
        return res;
    }

    @Override
    public int hashCode() {
        return lhs.hashCode() + 3*rhs.hashCode();
    }

    public boolean equals(Object other) {
        if (!(other instanceof ParseRule)) {
            return false;
        }
        if (!lhs.equals(((ParseRule) other).lhs)) {
            return false;
        }
        return rhs.equals(((ParseRule) other).rhs);
    }

    public boolean hasRHS() {
        return !rhs.isEmpty();
    }

    public Node lastRHS() {
        return rhs.get(rhs.size() - 1);
    }

    public List<Node> drop() {
        List<Node> res = new LinkedList<>();
        for (int i = 0; i < rhs.size() -1; i++) {
            res.add(rhs.get(i));
        }
        return res;
    }
}
